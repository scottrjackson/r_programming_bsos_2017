---
title: "Day 8 Lecture"
output: html_document
---

# Review HW 7

# Loops and control
  - if/else
  - for-loops
    - counters (sets)
    - "growing" results
    - debugging
    - break, next
  - simulating data
  - "roll your own" power analysis

# if/else
  - form: if(LOGICAL TEST) { CODE BLOCK if TEST == TRUE  }
  -       else(OPTIONAL ADDITIONAL TEST { CODE BLOCK if TRUE }   <-- "else" code only tested if initial "if" fails

```{r}
x <- 0
if(x > 1){
  print(x)
}

x <- 3
if(x > 1) {
  print("you have enough!")
} else {
  print("you need more!")
}

x <- 2
if(x > 3) {
  print("you have too many!")
} else if(x < 3) {
  print("you need more!")
} else {
  print("just right!")
}

x <- c(1:10, rep(NA, 3))
if(anyNA(x)) {
  number.of.NAs <- sum(is.na(x))
  print(paste("The mean (ignoring", number.of.NAs, "missing values) is", mean(x, na.rm = TRUE)))
} else {
  print(paste("The mean is", mean(x)))
}

```

  - `ifelse()`
    - arguments are: test = [LOGICAL TEST], yes = [VALUE if TEST == TRUE], no = [VALUE if TEST == FALSE]

```{r} 
result <- ifelse(x > 3, "yay", "oh no!")

x <- 4
result <- ifelse(x > 3, "yay", ifelse(x < 3, "oh no!", "well, okay"))
result

```

# PRACTICE #1 & #2

# for loops
  - simple way to iterate through a set of code, via a "counter" variable
  - avoid re-writing code, when possible!

```{r}
mydf <- data.frame(x = rnorm(n = 1000000, mean = 2, sd = 1), group = rep(1:1000, each = 1000))

rep(1:3, 3)
rep(1:3, each = 3)
rep(1:3, each = 3, 2)

this.vector <- mydf[mydf$group == 1, "x"]
my.answer1 <- mean(this.vector)
this.vector <- mydf[mydf$group == 2, "x"]
my.answer2 <- mean(this.vector)
this.vector <- mydf[mydf$group == 3, "x"]
my.answer3 <- mean(this.vector)

# MAKE IT A LOOP

for(my.counter in 1:10) {
  print(my.counter * 2)  
}

for(i in c(9, 4, 25)) {
  print(i * 2)  
}

for(this.name in c("Ally", "Bob", "Carol")) {
  print(this.name)
}

# Won't work, because loop needs "my.answer" to exist
rm(my.answer)
for(this.group in c(1, 2, 3)) {
  this.vector <-  mydf[mydf$group == this.group, "x"]
  my.answer[this.group] <- mean(this.vector)  # subset of my.answer not available because my.answer doesn't exist
}

# Will work, but may get very slow
my.answer <- NA
for(this.group in 1:1000) {
  this.vector <-  mydf[mydf$group == this.group, "x"]
  my.answer[this.group] <- mean(this.vector)
}

# system.time()

# BEST PRACTICE: pre-create the "results" object, with the proper size,
#                to be "filled in" by the loop
my.answer <- rep(NA, 1000)

my.groups <- 1:1000

my.answer <- vector(length = length(my.groups))
for(this.counter in 1:length(my.groups)) {
  this.group <- my.groups[this.counter]
  this.vector <- mydf[mydf$group == this.group, "x"]
  my.answer[this.counter] <- mean(this.vector)
}

```

# simulating data
  - d/p/q/r* family of functions for different distributions

```{r}
?rnorm

x <- sort(rnorm(1000))
summary(x)
sd(x)
hist(x)
plot(x)
plot(dnorm(x) ~ x)
plot(pnorm(x) ~ x)
plot(qnorm(seq(0, 1, .01)) ~ seq(0, 1, .01))

y <- rnorm(1000, mean = 1, sd = 2)
summary(y)
sd(y)

library(MASS)

cor.table <- matrix(c(1, .2, .2, 1), nrow = 2)
cor.table
some.data <- mvrnorm(n = 10, mu = c(1, 2), Sigma = cor.table, empirical = TRUE)
some.data
cor(some.data[, 1], some.data[, 2])
as.data.frame(some.data)
```

# Combining sims and loops

```{r}
mu.sigmas <- data.frame(mean1 = c(0, 0.1, -0.1, -0.3, 0.25), mean2 = c(0.2, 0.0, 0.3, -0.15, -0.1), corr = c(.2, .4, .1, .35, -0.3))

data.sets <- list()
length(data.sets) <- 5
for(i in 1:5) {
  data.sets[[i]] <- data.frame(mvrnorm(n = 1000, mu = c(mu.sigmas[i, "mean1"], mu.sigmas[i, "mean2"]), Sigma = matrix(c(1, mu.sigmas[i, "corr"], mu.sigmas[i, "corr"], 1), ncol = 2)))
  data.sets[[i]]$set <- i
  write.csv(data.sets[[i]], file = paste("sampledata", i, ".csv", sep = ""), row.names = FALSE)
}

```

# Power analysis

```{r}
# set up the parameters of the simulation
n.sim <- 10000
sample.n <- 100
correlation <- .2

cortable <- matrix(c(1, correlation, correlation, 1), ncol = 2)
# "pre-allocate" the results table
results <- data.frame(iteration = 1:n.sim, p = NA)

for(counter in 1:n.sim) {
  this.data <- as.data.frame(mvrnorm(sample.n, mu = c(0, 0), Sigma = cortable))
  this.cortest <- cor.test(this.data$V1, this.data$V2)
  results[counter, "p"] <- this.cortest$p.value
  if(counter %% 100 == 0) {
    print(paste("finished simulation #", counter))
  }
}
results$sig <- ifelse(results$p < .05, TRUE, FALSE)
head(results)
sum(results$sig)/nrow(results)

```

